4.10 2025 HIT RATE = 45%; SCORE = тест не засчитан за использование нейронки;

**Вы работаете с распределенной системой, которая обрабатывает миллионы записей. При попытке внедрить быструю сортировку (quicksort) в условиях параллельной обработки на нескольких узлах результаты оказались нестабильными. Время выполнения варьируется, и на некоторых узлах наблюдается перегрузка памяти.**
Какой подход следует выбрать, чтобы обеспечить детерминированное поведение и равномерную нагрузку при масштабировании сортировки?

Использовать параллельное слияние после завершения сортировки на каждом узле
Включить механизм кеширования на уровне системы ввода-вывода
Настроить сбалансированное распределение нагрузки между узлами
V **Выбрать алгоритм сортировки слиянием для его детерминированности**
Переходить на более мелкие пакеты данных и выполнять их последовательную сортировку


**Вы разрабатываете систему поиска в структуре данных с динамическими изменениями, такой как граф или дерево, где необходимо учитывать изменяющуюся структуру.**
Вы определили для себя такие условия:

Количество узлов может достигать 100 миллионов, и связи между узлами изменяются в реальном времени
Алгоритм поиска должен минимизировать затраты на обновление структуры данных
Важно учитывать динамические изменения при выборе наиболее подходящего метода поиска
Что применить, чтобы обеспечить наилучшую производительность при этих условиях?

Применять жадный алгоритм (например, жадный поиск А*) без учета изменений структуры
Оценить стоимость всех возможных путей в графе с учетом возможных циклов и их влияния на скорость поиска
V **Учитывать сложность динамических изменений структуры данных и выбирать алгоритм, минимизирующий затраты на обновления**
Рассматривать использование многократных индексаций и предварительных вычислений для ускорения поиска
Выбирать алгоритм, который будет эффективен только при статической структуре данных


**В вашем проекте требуется организовать структуру данных для эффективного выполнения операций поиска, добавления и удаления элементов при высоких нагрузках.**
Вам известно следующее:

Объем данных превышает 10 миллионов записей
Система ограничена в оперативной памяти (не более 1 ГБ)
Средняя нагрузка 100 тысяч операций в минуту
Требуется минимизировать задержки при поиске и обновлении данных
Почему в условиях этого сценария хеш-таблица может оказаться неидеальным решением, несмотря на высокую скорость выполнения операций?

V **Хеш-таблица требует хранения хешей и связей, что увеличивает потребление памяти, особенно при использовании методов открытой адресации**
Поиск в хеш-таблице невозможен без точного знания ключа, что усложняет обработку данных с иерархической структурой
Значительные накладные расходы на разрешение коллизий могут привести к росту времени поиска в худших случаях
Хеш-таблица увеличивает время доступа к данным в условиях конкурентного использования памяти с множеством параллельных потоков
Упорядоченный обход элементов невозможен, что делает хеш-таблицы неэффективными в задачах, требующих итерационного поиска по диапазону


**В многопоточной системе обработки данных после внедрения нового механизма управления потоками была зафиксирована следующая ситуация:**
Пропускная способность значительно возросла, но при этом:

Некоторые потоки стали получать приоритетный доступ к данным, вызывая неравномерную загрузку ресурсов

Система стала более сложной в отладке из-за трудностей в выявлении ошибок конкурентного доступа
Какие шаги могли привести к такому результату?

Оптимизация алгоритма синхронизации за счет сокращения количества блокировок и упрощение механизма проверки состояния потоков

Удаление блокировок при доступе к данным и переход на lock-free очередь без учета возможных гонок данных

Переработка структуры очереди с целью уменьшения накладных расходов на ожидание и внедрение механизма атомарного обновления данных

Введение стратегии динамического перераспределения потоков и отказ от явных приоритетов доступа к ресурсам

V **Замена стандартной mutex-based очереди на lock-free структуру и отказ от механизма балансировки нагрузки между потоками**


**В вашей компании, занимающейся анализом логов (журналов событий) с нескольких серверов, долгое время применялся метод опорных векторов (SVM) для классификации записей.**
Однако объемы данных продолжали расти, и вы решили перейти на логистическую регрессию, чтобы ускорить процесс обучения и упростить масштабирование. По результатам тестов выяснилось, что логистическая регрессия действительно обучается быстрее, но итоговая точность может заметно колебаться в зависимости от структуры и размера поступающих логов.
С учетом того, что решение принималось не как выбор ML-модели, а как архитектурная замена ресурсоемкого алгоритма на более масштабируемый, в чем причина таких изменений?

V **Логистическая регрессия сильно зависит от линейной разделимости данных, и если данные не линейно разделимы, точность меняется в зависимости от структуры и размера логов**
Логистическая регрессия автоматически масштабирует признаки и всегда работает с изменчивой точностью за ( O(log n) ), независимо от структуры данных
Логистическая регрессия требует значительно большего объема памяти при работе с большими логами, что негативно влияет на точность модели
Логистическая регрессия по определению применима только к симметрично распределённым данным и не может адаптироваться к неравномерной выборке
Логистическая регрессия не учитывает размер выборки и сохраняет постоянно колеблющуюся точность при обучении независимо от объема и размера логов


**Ваше приложение обрабатывает миллиарды записей в реальном времени, но система неожиданно начала потреблять больше памяти, чем было рассчитано. Логирование показало, что значительная часть памяти уходит на накладные расходы структуры данных.**
Что наиболее вероятно приводит к повышенному расходу памяти?

Ограничение числа одновременно загруженных структур данных
Использование сжатия данных
V **Использование деревьев поиска вместо хеш-таблиц**
Применение memory-mapped файлов
Замена динамического выделения памяти на статическое


**Вы реализуете рекурсивный алгоритм, однако с увеличением глубины рекурсии происходит значительное замедление и превышение лимита стека. В некоторых случаях выполнение завершается с ошибкой переполнения памяти.**
Что является наиболее вероятной причиной этой проблемы?

Рекурсивные вызовы без оптимизированного условия выхода приводят к увеличению глубины стека
Использование глобальных переменных для хранения промежуточных результатов может увеличивать потребление памяти
Передача большого массива в рекурсивные вызовы увеличивает накладные расходы
V **Чрезмерная глубина рекурсии без мемоизации приводит к переполнению стека**
Неэффективное выделение памяти для локальных переменных может привести к увеличению потребления ресурсов


**Вы анализируете логи работы алгоритма Дейкстры, используемого в навигационной системе умного города. Полученные маршруты вызывают сомнения, и вам нужно определить, соответствует ли структура графа требованиям алгоритма.**
В вашей программе после выполнения алгоритма Дейкстры лог системы вывел следующий путь: А → С → F → H → G
Какие выводы можно сделать о структуре графа и корректности работы алгоритма, основываясь на данном маршруте?

V **Граф направленный, все ребра имеют положительные веса, а сам алгоритм отработал корректно**
Маршрут мог быть построен некорректно из-за возможного наличия циклов в графе
Один выбранный маршрут не дает полной информации о числе связей у вершин графа
Наличие отрицательных ребер могло бы привести к ошибкам в алгоритме Дейкстры
Алгоритм Дейкстры использует жадный метод, выбирая ближайшую вершину на каждом шаге пути


**Вы разрабатываете распределенную систему обработки данных, в которой хеш-таблица используется для быстрого доступа к записи журнала событий. После развертывания на тестовом окружении было выявлено, что время поиска отдельных записей значительно увеличивается по мере накопления данных. Дополнительный анализ показал, что в таблице образуется несколько «горячих» бакетов, содержащих непропорционально большое число элементов, что приводит к росту времени поиска.**
Какой фактор вызывает такой рост?

Применение связных списков внутри бакетов исключает возможность накопления элементов в одном сегменте
V **Использование плохой хеш-функции, приводящей к неравномерному распределению ключей**
Добавление большего количества бакетов приводит к сильному росту коллизий
Рехеширование таблицы после каждой вставки значительно ускоряет доступ
Ограничение глубины цепочек в методе цепочного хеширования


**Выберите вариант ответа, в котором перечислены только ключевые метрики, определяющие производительность хеш-таблицы.**

Частота рехеширования, глубина пробирования, общее число записей
V **Коэффициент загрузки, количество коллизий, среднее время нахождения данных**
Распределение данных, максимальная длина цепочки, сложность хеш-функции
Размер таблицы, количество операций вставки, использование связных списков
Процент занятых ячеек, число доступных бакетов, время вычисления хеш-функции


**В модуле сравнения текстов вы реализовали рекурсивную функцию, вычисляющую длину наибольшей общей подпоследовательности (LCS) для двух строк длиной до 10 000 символов каждая. Профилировщик показал, что функция тратит большую часть времени на повторные вычисления одних и тех же подзадач — например, многократно сравниваются одни и те же префиксы строк.**
Какой приём позволит радикально сократить время работы алгоритма, сохранив корректный результат?

Использовать «жадный» выбор: сразу добавлять любой совпавший символ, если он встречается в обеих строках
Ограничить глубину рекурсии фиксированным порогом, прерывая вычисления при его достижении
Переписать алгоритм в итеративном стиле, полностью отказавшись от рекурсии, без хранения промежуточных результатов
Кешировать только последние удачные совпадения символов, игнорируя остальные подзадачи
V **Сохранять результаты уже решённых подзадач (мемоизация) и переиспользовать их при повторных вызовах**


**Вы разрабатываете систему навигации для транспортной компании, которая оптимизирует маршруты грузоперевозок между городами. Тестирование показало, что при увеличении количества точек доставки время расчета маршрутов резко возрастает, что приводит к задержкам в системе.**
Как можно оптимизировать поиск маршрутов?

Применить алгоритм полного перебора, чтобы учесть все маршруты
Удалить ребра с большим весом, чтобы сократить количество проверок
V **Использовать алгоритм А* с эвристиками для ускорения поиска**
Использовать DFS для поиска кратчайшего пути
Настроить использование неориентированного графа вместо ориентированного


**При решении задачи поиска длины наибольшей общей подпоследовательности (LCS) между двумя строками было замечено, что одни и те же подстроки сравниваются повторно. Это привело к существенному росту времени выполнения при увеличении длины строк.**
Какой признак указывает на возможность применения динамического программирования в такой задаче?

Требует минимального времени, но допускает произвольный порядок вызова функций
Должна быть линейной по используемой памяти и логарифмической по времени
Допускает решение через уже строго отсортированный массив входных данных
Не требует хранения промежуточных данных при любом подходе в их дальнейшей обработке
V **Разбивается на перекрывающиеся подзадачи с возможностью переиспользования результатов**


**Какой алгоритм используется для построения минимального остовного дерева?**

Алгоритм Дейкстры
Алгоритм Беллмана-Форда
Алгоритм А* с эвристиками
Алгоритм Флойда-Уоршелла
V **Алгоритм Крускала**


**Какой метод НЕ является оптимальным для решения задачи линейного программирования с жесткими ограничениями?**

Использование динамического программирования для разбиения задачи на подпроблемы
Применение симплекс-метода для нахождения глобального оптимального решения
Использование линейного поиска для нахождения допустимых значений переменных
Применение метода градиентного спуска для оптимизации многомерных функций
V **Использование жадного алгоритма, который принимает локально оптимальные решения на каждом шаге**


**Вы оптимизировали код, использующий быструю сортировку (Quicksort). Однако в некоторых случаях производительность алгоритма оказалась хуже, чем у сортировки вставками, особенно на больших наборах данных.**

Почему это могло произойти?

V **Неудачный выбор опорного элемента, из-за которого алгоритм мог деградировать до ( O(n^2) ), если разбиение происходит неравномерно**
Выбран неподходящий компилятор, который не влияет напрямую на алгоритмическую сложность сортировки
Применение multithreading могло повлиять на параллельную производительность и общую базовую сложность алгоритма
Использование нерекурсивного подхода могло принципиально изменить поведение алгоритма
Оптимизация кеширования могла существенно снизить своевременный доступ при работе алгоритма к необходимым данным


**Вы работаете над системой быстрого поиска данных, где необходимо минимизировать количество операций сравнения.**
Ограничения:

Линейный поиск не подходит, так как его сложность ( O(n) ) делает его неэффективным для больших данных.
Бинарное дерево поиска (BST) деградирует до ( O(n) ) в худших случаях (например, если дерево несбалансированное).
Система работает с 5 миллиардами записей, а среднее время отклика на запрос не должно превышать 2 миллисекунды.
Как обеспечить наилучшую производительность при этих условиях?

Настроить балансировку бинарного дерева для оптимизации поиска
Использовать битовые индексы для ускорения фильтрации данных
Применить интерполяционный поиск для ускорения работы в отсортированных данных
Использовать линейный поиск для более стабильной работы
V **Добавить хеш-таблицу для мгновенного поиска за ( O(1) )**


**В вашей компании разрабатывается интеллектуальная система распределения грузов по железной дороге, в которой используется граф с динамически изменяющимися тарифами. Некоторые тарифы (например, скидки за обратный рейс или таможенную проверку) могут иметь отрицательные веса. В тестах ваш алгоритм дал корректные результаты.**

Что изменить, чтобы тесты НЕ дали корректные результаты с отрицательными весами?

V **Заменить вариант ранее используемого алгоритма на алгоритм Дейкстры**
Закрепить использование вершин с отрицательными весами
Применить модификацию алгоритма Флойда-Уоршелла, которая заменяет отрицательные рёбра на положительные
Ограничить глубину поиска маршрутов, чтобы предотвратить влияние отрицательных рёбер
Добавить рёбра с очень большими положительными весами


**В системе автоматической навигации для логистической компании маршруты строятся на взвешенном ориентированном графе. Тестирование выявило проблемы:**

Время расчета резко возрастает при увеличении точек доставки
Один и тот же граф при повторном запуске дает разные корректные маршруты с разной длиной
Примеры расхождения:
S → A → C → E → T vs S → B → D → T

Какое изменение в алгоритме или структуре графа могло привести к такому поведению?

Добавление новых ребер с другими весами нарушило исходную маршрутизацию
Использование алгоритма поиска в глубину вместо алгоритма Дейкстры
V **Использование эвристики при выборе ребер**
Изменение структуры данных хранения графа
Приоритет обработки узлов в очереди изменил порядок выбора пути


**Какой фактор НЕ влияет на борьбу с коллизиями в хеш-таблицах?**

Динамическое увеличение размера таблицы при превышении порога заполнения
Использование качественной хеш-функции для равномерного распределения данных
V **Использование многопоточной обработки для параллельного доступа к таблице**
Выбор метода разрешения коллизий, возникающих при обработке хеш-таблицы
Оптимизация внутренней структуры хранения данных при возникновении коллизий


**В вашей системе управления данными связные списки используются для хранения информации. При частом доступе к произвольным элементам производительность снизилась.**

Какое решение НЕ позволит существенно повысить скорость без значительного увеличения накладных расходов?

Использование пропускных списков, так как оно ускоряет поиск, но требует усложненной логики вставки/удаления
Применение хеш-таблицы, так как оно ускоряет доступ, но требует вычислений для поддержки коллизий
V **Замена односвязного списка на двусвязный, так как она не ускоряет поиск, а лишь увеличивает расход памяти**
Связный список, так как он требует последовательного обхода элементов
Использование дополнительной индексации, так как оно увеличивает скорость поиска, но требует затрат памяти


**В корпоративной системе наблюдаются задержки при сортировке, вызванные большим количеством одинаковых значений. Алгоритм быстрой сортировки работает нестабильно.**

Какую технику стоит применить для повышения эффективности?

V **Использовать трехпутовое разбиение в быстрой сортировке для обработки дубликатов**
Внедрить адаптивный алгоритм сортировки, учитывающий почти полное отсутствие различий в формате данных
Включить в свой алгоритм механизм предварительной выборки уникальных значений
Добавить в свой алгоритм подсчет частоты элементов перед самым началом сортировки
Использовать карманную сортировку для группировки одинаковых значений


**Вы разрабатываете алгоритм для поиска минимального количества разрезов строки, необходимых для разбиения ее на палиндромы. Первоначальная версия  использует рекурсивный подход, но при длинных строках время выполнения  возрастает экспоненциально. Проверка показала, что некоторые подстроки  анализируются несколько раз.**

Какой метод поможет уменьшить избыточные вычисления и повысить производительность?

Использовать алгоритм полного перебора для точного расчета оптимального варианта
Применить жадный алгоритм разбиения строк, снизив число рассмотренных вариантов
Увеличить глубину рекурсии для детального анализа каждого возможного разбиения
V **Использовать динамическое программирование для хранения уже рассчитанных разрезов**
Добавить дополнительный уровень предобработки строк перед разбиением


**Почему алгоритм Дейкстры не подходит для поиска кратчайшего пути в графе с отрицательными весами?**


Алгоритм использует неэффективное кеширование путей
В этом случае алгоритм не будет работать в ориентированных графах
Алгоритм Дейкстры потребует матрицы смежности для таких весов
V **Жадная стратегия не учитывает отрицательные веса корректно**
Время выполнения алгоритма слишком велико для таких задач


**Вы проектируете хеш-таблицу для хранения кэша результатов запросов в высоконагруженной системе. После роста нагрузки скорость извлечения данных снизилась, а потребление памяти увеличилось.**

Почему это приводит к снижению производительности?

Добавление резервных бакетов привело к избыточному потреблению памяти и замедлило обработку
Изменение стратегии разрешения коллизий улучшило равномерность распределения
Использование открытой адресации вместо метода цепочек привело к зависимости от структуры данных
V **Коэффициент загрузки таблицы превысил оптимальное значение, увеличив количество коллизий**
Распределение нагрузки на несколько таблиц привело к появлению подобной проблемы


**Вы разрабатываете рекурсивный алгоритм обработки данных, который выполняет вложенные вызовы.** 
При больших объемах входных данных время выполнения увеличивается нелинейно.
Исследование показало, что алгоритм пересчитывает одни и те же значения на каждом уровне рекурсии.

Какой фактор наиболее вероятно приводит к росту времени выполнения?

Передача больших объектов между рекурсивными вызовами увеличивает нагрузку на стек и замедляет алгоритм
V **Отсутствие кеширования промежуточных результатов приводит к увеличению сложности алгоритма**
Рекурсивные вызовы с глубокой вложенностью требуют больше памяти и могут привести к превышению лимита стека
Использование глобальных переменных снижает производительность из-за необходимости синхронизации при каждом вызове
Оптимизации, выполняемые компилятором, могут непредсказуемо изменять порядок вычислений и замедлять выполнение


**Вы разрабатываете систему поиска данных в большом неупорядоченном массиве, где необходимо значительно сократить время поиска.**

Вы определили для себя такие условия:

**Использование линейного поиска приводит к временной сложности ( O(n) ), что делает его неэффективным для больших объемов данных.**
Размер массива составляет 1 миллиард записей, что требует высокой производительности алгоритма.
Среднее время отклика на запрос не должно превышать 1 миллисекунду.
Какой подход к организации поиска позволит обеспечить лучшую производительность в заданных условиях?

Применить бинарный поиск для значительного ускорения
Переключиться на жадный алгоритм поиска, который обходит только часть массива
Использовать индексы и частичную предобработку для ускоренного поиска
Разделить массив на равные части и применять поиск последовательности
V **Добавить хеш-таблицу для быстрого поиска за ( O(1) )**


**В системе потоковой аналитики все входящие события обрабатываются через одну глобальную очередь.**
После увеличения числа потоков и нагрузки были зафиксированы:

Рост времени отклика
Ухудшение масштабируемости
Падение cache-локальности
Почему производительность системы снизилась, несмотря на увеличение количества потоков?

FIFO поведение очереди блокирует новые задачи до завершения старых, что вызывает задержки
Добавление потоков увеличивает контекстные переключения, нарушая предсказуемость выполнения
V **Глобальная очередь становится точкой конкуренции, увеличивая накладные расходы на синхронизацию**
Очередь организована как стек, что нарушает порядок поступления задач
Очередь с блокировкой не позволяет потокам использовать кеш-память эффективно


V **Вы разрабатываете систему, где важно минимизировать использование памяти. Однако, несмотря на расчеты, текущее потребление памяти оказалось выше ожидаемого.**

Какой фактор может быть причиной увеличенного расхода памяти?

Хеш-таблица требует хранения хешей, но это незначительно увеличивает накладные расходы по сравнению со связными списками
V **Использование связных списков приводит к дополнительным накладным расходам из-за хранения указателей между элементами**
Префиксное дерево (trie) использует сжатие данных, но не увеличивает накладные расходы на хранение указателей
Динамический массив требует перераспределения памяти при изменении размера, но не создает дополнительных накладных расходов на указатели
Куча выделяет память динамически, но не увеличивает накладные расходы за счет указателей


**В многопоточной системе запущен рекурсивный алгоритм, который работает с большим количеством данных. Однако при увеличении нагрузки время отклика системы резко возрастает, а потребление памяти выходит за установленные лимиты.**

Исследование выявило:

Рекурсивные вызовы продолжают накапливаться в стеке при увеличении объема входных данных.
Некоторые потоки завершаются с ошибкой переполнения памяти.
Система замедляется при выполнении глубоких рекурсивных вычислений.
Что может быть основной причиной этого поведения?

Использование статических переменных приводит к увеличенному потреблению памяти
Рекурсивные вызовы с большой глубиной не могут быть оптимизированы компилятором
Использование конкурентного доступа к памяти увеличивает задержки в системе
Увеличение количества потоков уменьшает общую пропускную способность
V **Отсутствие хвостовой рекурсии приводит к накоплению вызовов в стеке**


**Какой из факторов может привести к ухудшению равномерности распределения ключей в хеш-таблице при обработке структурированных данных?**

Использование хеш-функции, возвращающей одно значение
V **Использование хеш-функции, игнорирующей часть ключа**
Применение метода цепочек без ограничения длины
Хеширование ключей делением значений на фиксированное число
Выбор размера хеш-таблицы, кратного степени двойки


**Вы разрабатываете алгоритм для вычисления наибольшей общей подпоследовательности (LCS) двух строк. При больших входных данных время выполнения резко возрастает, а использование памяти выходит за допустимые пределы. Анализ логов выявил, что программа сохраняет значения для всех возможных подзадач, включая те, которые не будут использованы повторно.**

Как снизить использование памяти без потери производительности?

Добавить более глубокие уровни рекурсивных вызовов в процессе
Переключиться на алгоритм полного перебора для увеличения точности
Уменьшить размер шага при разбиении задачи на подзадачи
Применить многопоточное вычисление всех подзадач параллельно
V **Использовать оптимизированное хранилище с двумя строками таблицы DP**


**Какой ключевой аспект отличает метод Беллмана-Форда при поиске кратчайших путей в разреженном взвешенном графе, содержащем как положительные, так и отрицательные ребра, но без циклов отрицательного веса?**

Одновременно обрабатывает все возможные пути, вычисляя кратчайшие расстояния за один шаг
V **Позволяет находить оптимальные маршруты даже при наличии снижающих стоимость переходов, корректируя расстояния на каждом шаге**
Принимает приближенные оценки, ускоряя процесс за счет сокращения полного количества анализируемых вариантов
Формирует минимальное остовное дерево, минимизируя суммарный вес соединений в графе
Обрабатывает полный набор возможных сочетаний узлов одновременно, вычисляя все промежуточные значения в графе