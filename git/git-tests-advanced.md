26.10 2025 HIT RATE = 27%; SCORE = 13 из 15 - ЗАЧЕТ;

**Команда разработчиков решила хранить большие бинарные файлы (изображения, видео и 3D-модели) в репозитории Git. Все изменения в них фиксируются напрямую в коммитах.**

**Репозиторий уже содержит 2 ГБ исходного кода и документации. Ежедневно добавляется около 200 МБ новых бинарных файлов с незначительными изменениями.**

**Оцените, насколько правильно использовать Git в таком сценарии, и объясните, как это повлияет на производительность и размер репозитория в долгосрочной перспективе.**

Это допустимо при условии регулярного выполнения git gc --aggressive для оптимизации хранилища объектов и удаления избыточных данных
Это некорректно, так как Git не умеет работать с файлами в кодировке, отличной от UTF-8
Это допустимо, если использовать shallow clone с глубиной не более 10 коммитов при работе с репозиторием: тогда операции будут достаточно быстрыми
V **Это некорректно: Git будет сохранять полные копии файлов при каждом изменении, это приведет к росту размера репозитория и замедлению операций**
Это нормальная практика: Git использует дельта-сжатие для всех типов файлов, поэтому размер репозитория будет расти линейно, а не экспоненциально


**Вы с коллегой работаете над новой функциональностью в API в ветке feature/api-implementation. В ветку main было внесено несколько исправлений ошибок, которые также присутствуют в вашей ветке. Однако в main есть и другие изменения, несовместимые с вашей текущей веткой. Ваш коллега выполнил действия для исправления этих ошибок в вашей ветке, не затрагивая остальные функции.**

Определите по текущему и предыдущему состояниям веток, какую последовательность команд выполнил ваш коллега.

Учтите: он точно не копировал изменения в вашу ветку вручную и не создавал новых коммитов с нуля.

Состояние ветки feature/api-implementation до изменений

80a8cf6: New api implementation
Изменения в файлах: api.js, models.js
1c69684: V2
Изменения в файлах: config.js, utils.js
99a9c09: V1
Изменения в файлах: index.js, package.json

Состояние ветки main

f7d21e: UI improvements
Изменения в файлах: ui.js, styles.css
d5bb6ba: V3
Изменения в файлах: config.js, database.js
e3a91c2: Security fix
Изменения в файлах: auth.js, api.js
c1e97f1: API hot-fix
Изменения в файлах: api.js
b2d83f4: Performance optimization
Изменения в файлах: utils.js, models.js
1c69684: V2
Изменения в файлах: config.js, utils.js
99a9c09: V1
Изменения в файлах: index.js, package.json

Текущее состояние ветки feature/api-implementation

7ae290f: Security fix
Изменения в файлах: auth.js, api.js
4fde353: API hot-fix
Изменения в файлах: api.js
2b8c1a5: Performance optimization
Изменения в файлах: utils.js, models.js
30a8cf6: New api implementation
Изменения в файлах: api.js, models.js
1c69684: V2
Изменения в файлах: config.js, utils.js
99a9c09: V1
Изменения в файлах: index.js, package.json

git format-patch main --stdout | git apply --reject && git commit -am "Apply fixes from main"
git rebase -i main --onto <hash>
V **git cherry-pick b2d83f4 c1e97f1 e3a91c2**
git checkout main api.js auth.js utils.js models.js && git commit -m "Apply fixes from main"
git merge main && git revert <hash>


**Вы работаете над проектом и замечаете, что изменения, которые касаются исправления ошибки в форме в ветке feature/data-form, исчезли, хотя раньше они точно были.**

Вы выполняете команду git log и видите следующий вывод:

1 commit 1c69684
2 Author: Some Developer
3 Date: Mon Dec 18 10:00:00 2024
4 Initial implementation of form functionality

1 commit 5f62b1c
2 Author: Some Developer
3 Date: Mon Dec 9 18:30:00 2024
4 Added database connection

После этого вы выполняете команду git reflog, чтобы посмотреть журнал операций с объектами в Git, и видите такой вывод:

1 5f62b1c HEAD@{0}: reset: moving to HEAD~1
2 a2f3143 HEAD@{1}: commit: Fix for form functionality
3 5f62b1c HEAD@{2}: commit: Initial implementation of form functionality

Какая команда была выполнена и какую команду теперь надо выполнить, чтобы восстановить ваши изменения?

Выполнена git reset --mixed, которая удалила коммит a2f3143 и оставила изменения в рабочей директории, а для восстановления надо выполнить git commit
Выполнена git revert, отменившая изменения из коммита a2f3143, а для восстановления надо выполнить git revert HEAD
V **Выполнена git reset --hard, которая удалила коммит a2f3143, а для восстановления надо выполнить git cherry-pick a2f3143**
Выполнена git reset --soft, которая удалила коммит a2f3143 и перенесла изменения в staging area, а для восстановления надо выполнить git commit
Выполнена git rebase, из-за которой коммит a2f3143 был потерян, а для восстановления надо выполнить git stash pop


**Вы работаете в ветке feature/new-customer-model, которая была создана командой git checkout -b feature/new-customer-model. После завершения разработки вы пытаетесь отправить изменения в удаленный репозиторий origin и выполняете команду git push origin.**

Какой результат вы получите и почему?

Команда завершится с ошибкой, так как перед push необходимо подписать коммиты с помощью git push -s
Команда успешно завершится, а в удаленном репозитории будет создана новая ветка
Команда завершится успешно, но с предупреждением о том, что была создана новая ветка
V **Команда завершится с ошибкой, так как локальная ветка еще не связана с удаленным репозиторием**
Команда завершится с ошибкой, так как origin не может быть именем удаленного репозитория


**Вы работаете в команде, использующей расширенную методологию Git Flow с дополнительными типами веток. Ваш проект имеет следующую структуру веток:**

main (стабильные релизы)
develop (текущая разработка)
release/* (подготовка релизов)
hotfix/* (срочные исправления)
feature/* (новые функции)
experimental/* (экспериментальные функции)
refactor/* (рефакторинг кода)
Один из ваших коллег выполнил следующие действия:

Создал ветку refactor/db-constraints от develop
Сделал в ней 15 небольших коммитов, каждый из которых рефакторит отдельную часть кода БД
Выполнил слияние ветки refactor/db-constraints в develop командой: git merge --squash refactor/db-constraints
Создал новый коммит в develop с подробным описанием всех изменений
Не удалил ветку refactor/db-constraints после слияния
Какой из следующих выводов отражает последствия таких действий с точки зрения расширенного Git Flow и управления историей изменений?

Не соответствует, так как после слияния с флагом --squash ветка refactor/db-constraints должна быть немедленно удалена, потому что ее история больше не имеет значения
Не соответствует, так как ветки refactor/* не предусмотрены в стандартной Git Flow, их следовало оформить как feature/*
Полностью не соответствует, так как в Git Flow всегда требуется использовать стандартное слияние (git merge --no-ff) для сохранения всей истории изменений, включая промежуточные коммиты даже для веток рефакторинга
Частично соответствует, но коллега должен был использовать git rebase перед слиянием, чтобы создать линейную историю, а затем выполнить fast forward merge
V **Соответствует для веток рефакторинга, так как объединение множества мелких изменений в один логический коммит с помощью --squash упрощает историю develop, при этом полная детализация изменений остается доступной в исходной ветке**


**Вы обнаружили ошибку в текущей версии проекта и хотите использовать команду git bisect для поиска коммита, который создал эту ошибку.**

Вы знаете, что ошибка не воспроизводится в коммите с хешем 99a9c09, а хеш коммита текущей версии проекта — c1e97f1.

Какую команду надо выполнить для начала работы с git bisect?

git bisect bad c1e97f1
git bisect good 99a9c09
git bisect start 99a9c09 c1e97f1
V **git bisect start c1e97f1 99a9c09**
git bisect reset


**Для чего используется Git Submodules?**

Для объединения нескольких репозиториев в один, чтобы они работали как единое целое
Для синхронизации версий файлов между несколькими проектами
Для удаления веток из другого репозитория
Для работы с несколькими независимыми репозиториями в одном проекте
V **Для отслеживания изменений в другом репозитории как части вашего текущего проекта.**


**Объясните, как технически работает Git LFS и какие преимущества он предоставляет по сравнению со стандартным Git при работе с большими файлами.**

Git LFS позволяет подключать внешнее хранилище через Git remote и хранить большие файлы отдельно от основного репозитория, но с теми же идентификаторами коммитов
Git LFS автоматически разбивает большие файлы на фрагменты и хранит только изменившиеся фрагменты при каждом коммите, это позволяет эффективно отслеживать изменения в бинарных файлах
V **Git LFS заменяет большие файлы в репозитории на текстовые указатели (pointer files), содержащие SHA-256 хеш и метаданные, а сами файлы хранятся на отдельном LFS-сервере, это ускоряет операции клонирования и извлечения**
Git LFS создает отдельный репозиторий для больших файлов и автоматически синхронизирует его с основным репозиторием при выполнении команд push и pull, это уменьшает размер основного репозитория
Git LFS использует специальный алгоритм сжатия для больших файлов, который эффективнее стандартного алгоритма Git, это позволяет хранить большие файлы с меньшими затратами дискового пространства


**Ваш коллега, работая над коммитами в ветке main, заметил: история коммитов в ней содержит коммит 3256012 с очень большим файлом debug.log и другими изменениями. Этот файл уже удален из репозитория в коммите 8dd9645, но всё еще существует в истории и усложняет работу с репозиторием. Он выполнил какую-то операцию с деревом коммитов и удалил этот файл из всех предыдущих коммитов.**

Начальное состояние ветки (вывод git log --oneline):

1 f1fe759 (HEAD -> main) Fixed documentation and comments
2 8dd9645 Removed debug.log
3 c6efbed Finished main feature
4 325b012 Added model implementation
5 e21d3cc Initial commit

Итоговое состояние ветки (вывод git log --oneline):

1 62db399 (HEAD -> main) Fixed documentation and comments
2 af98fe5 Removed debug.log
3 f7048f0 Finished main feature
4 4d1dde5 Added model implementation
5 e21d3cc Initial commit

Какую операцию из перечисленных выполнил ваш коллега?

Выполнил git cherry-pick для удаления файла и пересоздал коммиты вручную
Выполнил git filter-branch --tree-filter "rm -f debug.log" --all
Выполнил git commit --amend, удалив файл вручную, а затем перезаписал историю командой git push --force
V **Выполнил git filter-branch --index-filter "git rm --cached debug.log" --all**
Выполнил git rebase -i для редактирования коммита и удаления файла


**Какой из следующих подходов наиболее эффективен для интеграции внешнего репозитория, когда требуется сохранить полную историю изменений внешнего проекта и иметь возможность вносить локальные изменения, не затрагивая основной репозиторий?**

Копирование файлов вручную и добавление их в .gitignore
Использование git subtree с опцией --squash
Использование git submodule с настройкой shallow clone
Использование git submodule с последующим форком подмодуля
V **Использование git subtree без опции squash**


**Разработчик случайно выполнил git reset --hard HEAD~3, удалив последние три коммита, которые еще не были отправлены в удаленный репозиторий.**

Какая последовательность команд позволит восстановить потерянные коммиты и создать новую ветку с этими изменениями?

V **1 git reflog**
  **2 git reset --hard HEAD@{3}**
  **3 git checkout -b recovery-branch**

1 git reflog show
2 git checkout HEAD@{3}
3 git checkout -b recovery-branch

1 git log --graph --all
2 git checkout <commit>
3 git checkout -b recovery

1 git log --all
2 git cherry-pick <commit-hash>
3 git push origin recovery-branch

1 git fsck --lost-found
2 git merge ORIG_HEAD
3 git branch recovery-branch


**В вашей компании используется CI/CD-система, которая автоматически развертывает приложение на основе Git-тегов. Вам необходимо создать новый релиз v2.5.0, который должен соответствовать следующим требованиям:**

Тег должен содержать подробное описание изменений в релизе.
Тег должен быть создан для определенного коммита с хешем a7d3f1c, а не для HEAD.
Тег должен быть доступен всем разработчикам через удаленный репозиторий.
В системе должна сохраниться информация о том, кто и когда создал этот тег.
Какая последовательность команд Git корректно выполнит все эти требования?

git checkout a7d3f1c && git tag v2.5.0 && git push origin v2.5.0
git tag -a version2.5.0 a7d3f1c -m "Release v2.5.0" && git push origin version2.5.0
git checkout a7d3f1c && git tag -s v2.5.0 -m "Release v2.5.0" && git push --tags
git tag -s v2.5.0 a7d3f1c -m "Release v2.5.0" && git push --follow-tags
V **it tag -a v2.5.0 a7d3f1c -m "Release v2.5.0" && git push origin v2.5.0**


**Вы работаете над сложным проектом и сталкиваетесь со следующей ситуацией:**

В ветке feature/auth вы внесли изменения в несколько файлов, часть из которых уже добавлена в индекс (staged).
Вам срочно нужно переключиться на ветку hotfix/security для исправления критической уязвимости.
Вы хотите сохранить только изменения в файлах, связанных с аутентификацией (auth*.js), но отбросить остальные изменения.
После завершения работы над hotfix вам нужно вернуться к работе над аутентификацией и восстановить только сохраненные изменения.
Вы хотите сохранить изменения локально, не отправляя их в удаленный репозиторий.

Какая из последовательностей команд Git позволит выполнить все эти действия?

1 git stash
2 git checkout hotfix/security
3 [работа над hotfix]
4 git checkout feature/auth
5 git stash pop

1 git stash push -m "auth changes" auth.js
2 git checkout hotfix/security
3 [работа над hotfix]
4 git checkout feature/auth
5 git stash pop

V **1 git add auth*.js**
  **2 git stash**
  **3 git reset hard**
  **4 git checkout hotfix/security**
  **5 [работа над hotfix]**
  **6 git checkout feature/auth**
  **7 git stash apply**

1 git stash save "auth changes"
2 git checkout hotfix/security
3 [работа над hotfix]
4 git checkout feature/auth
5 git stash apply stash@{0}

1 git commit -am "WIP: auth changes"
2 git checkout hotfix/security
3 [работа над hotfix]
4 git checkout feature/auth
5 git reset HEAD~1


**В проекте с микросервисной архитектурой обнаружена критическая уязвимость безопасности, внесенная коммитом abc123 два месяца назад. Этот коммит затрагивает общую библиотеку аутентификации, используемую во всех сервисах. Ситуация осложняется следующими факторами:**

После проблемного коммита было сделано более 200 коммитов в основной ветке.
От основной ветки было создано пять релизных веток, в которых также есть этот коммит.
Несколько команд разработчиков создали feature-ветки от разных точек истории.
Некоторые последующие коммиты в основной ветке частично исправляют проблему, но не полностью.
Все затронутые ветки уже развернуты в различных средах (тестовой, препродакшен, продакшен).
Какая стратегия будет эффективной для устранения уязвимости во всех ветках с минимальным риском нарушения работы проекта?

Создать hotfix-ветку от точки до проблемного коммита, внести исправления и выполнить слияние этой ветки со всеми затронутыми ветками
Использовать git rebase -i для редактирования проблемного коммита в каждой ветке, с последующим принудительным обновлением (force-push)
Использовать git bisect для точного определения проблемного кода, создать патч и применить его ко всем веткам с помощью git am
V **Создать единый исправляющий коммит с помощью git revert abc123 в основной ветке и затем выполнить cherry-pick этого коммита во все релизные ветки**
Создать серию revert-коммитов для проблемного коммита и всех коммитов, которые частично его исправляли, затем создать новый коммит с полным исправлением


**Вы работаете над проектом. В ветке feature/mvp у вас есть несколько коммитов, и вы хотите исправить последние три коммита, включая текущий.**

В одном из них есть ошибка, которую вы хотите исправить, а в другом неудачное название.

Вы хотите изменить порядок коммитов, исправить ошибку и изменить название коммита, чтобы улучшить историю проекта перед push изменений в основную ветку.

Какую команду в Git надо использовать, чтобы выполнить всё это в интерактивном режиме?

git reset -i HEAD~3
git merge --no-ff feature/mvp
V **git rebase -i HEAD~3**
git cherry-pick HEAD~3
git pull --rebase -i HEAD~3


**Разработчик вручную редактирует файлы в git/objects, чтобы восстановить поврежденные данные.**

Оцените корректность такого подхода.

Это невозможно — файлы в директории git являются readonly
V **Это некорректно — такие действия могут привести к повреждению репозитория**

Это корректно, если он точно знает структуру объектов

Это допустимо при работе с низкоуровневыми командами Git

Это некорректно — редактирование возможно, только если используется bare-репозиторий


**Вы сделали git cherry-pick коммита из ветки legacy-fixes в main. После этого вы заметили, что содержимое файла auth.js совпадает с нужным, но в истории появился дубликат коммита с другим хешем.**

Какой вывод можно сделать из данного состояния?

При выполнении cherry-pick Git делает копию коммитов

Перед cherry-pick была выполнена команда, которая дублирует коммиты
V **Cherry-pick создает новый коммит, но с идентичным содержанием**

Ветка main уже содержала аналогичные изменения, но cherry-pick их дублировал

Git сохраняет SHA-1 идентичным, но при выводе истории заменяет его, чтобы избежать дубликатов


**Вы создаете новую ветку feature/refactor-auth и работаете в ней над улучшением аутентификации. Затем вы переключаетесь обратно в ветку develop:**
git checkout develop
И выполняете:
git merge feature/refactor-auth
После этого Git автоматически завершает слияние, не сообщая о конфликтах. Однако вы замечаете, что часть изменений из feature/refactor-auth отсутствует.

Что могло произойти?
V **Вы переключились на develop до того, как закоммитили изменения в feature/refactor-auth, поэтому merge не включил ожидаемые правки**

В ветке feature/refactor-auth не было новых коммитов по сравнению с develop, поэтому merge не принес изменений

Ветка feature/refactor-auth была сброшена к develop, и Git не нашел различий между ними

Merge не работает без флага —no-ff, поэтому изменения не были приняты

Коммиты из feature/refactor-auth были случайно удалены из reflog перед merge


**В процессе работы с git bisect вы столкнулись с коммитом, который невозможно проверить из-за отсутствия нужной среды. Что нужно сделать в этой ситуации?**

Объявить коммит хорошим командой git bisect good

Объявить коммит плохим командой git bisect bad
V **Пропустить этот коммит командой git bisect skip**

Повторить команду git bisect start с другими хешами

Сбросить bisect командой git bisect reset


**Что необходимо сделать, чтобы клонировать репозиторий с подмодулями и сразу получить содержимое подмодулей?**

Клонировать репозиторий и выполнить git checkout на ветке подмодуля

Клонировать репозиторий и выполнить git pull —recurse-submodules

Клонировать репозиторий и выполнить git fetch —all
V **Клонировать репозиторий с параметром —recurse-submodules**

Клонировать репозиторий и запустить git submodule add для каждого подмодуля


**Команда решила удалить поддержку Git LFS из проекта. Какие шаги необходимы, чтобы безопасно удалить Git LFS и вернуть файлы в основной репозиторий?**

Удалить .gitattributes и заново выполнить git add чтобы перезаписать файлы в истории
V **Выполнить git lfs migrate export --include="*" для замены pointer-файлов оригинальными файлами и удалить .gitattributes**

Переместить все файлы в новую директорию, удалить LFS-ссылки и закоммитить изменения

Использовать git lfs uninstall и выполнить полное удаление всех больших файлов из истории Git

Заменить pointer-файлы на реальные вручную и сделать "force-push" в основную ветку


**Ветка feature содержит несколько коммитов с неудачно закоммиченным файлом config.yaml, который позже был исправлен. В результате команда решила полностью удалить все изменения файла из истории, чтобы избежать раскрытия конфиденциальных настроек.**

Исходное состояние ветки (вывод git log --oneline):
a405c67 (HEAD -> feature) Refactored service logic
d9f8a11 Fixed config.yaml typo
7c1d372 Added temporary config.yaml
e3a98cd Initial commit

После переписывания истории, чтобы удалить файл config.yaml, вывод git log --oneline стал таким:
b9e74d2 (HEAD -> feature) Refactored service logic
41f3b08 Initial commit

Какую операцию выполнила команда?

Выполнила git revert на коммите config.yaml

Выполнила git commit --amend и git push --force
V **Выполнила git filter-branch --index-filter "git rm --cached config.yaml" -- --all**

Выполнила git cherry-pick для создания новой ветки без config.yaml

Выполнила git rebase -i с удалением коммитов, содержащих изменения файла


**В процессе интерактивного перебазирования (git rebase -i HEAD~4) разработчик случайно выбрал опцию drop для одного из важных коммитов. Он осознал ошибку сразу после завершения перебазирования. Каким способом можно найти этот «потерянный» коммит и применить его (например, через cherry-pick) к текущей вершине ветки?**

git log --all --grep="<уникальная_часть_сообщения_коммита>", найти хеш, git cherry-pick <найденный_хеш>

git fsck --lost-found ,перейти в каталог .git/lost-found/commit , найти файл коммита, git cherry-pick <хеш_из_имени_файла>
V **git reflog , найти хеш коммита, который был удален (он будет в reflog с его состоянием до начала rebase), затем git cherry-pick <хеш_потерянного_коммита>**

git reset --hard ORIG_HEAD (чтобы отменить весь rebase), затем повторить git rebase -i HEAD~4 более внимательно

git rebase --short (не сработает, т.к. rebase уже завершен), затем искать коммит вручную


**Ваш коллега создал тег test-build-1 на удаленном репозитории, но забыл его локально. Вам нужно получить этот тег, чтобы использовать его в своей работе, но без получения всех остальных новых тегов.**

Какая команда Git позволит получить только этот конкретный тег из удаленного репозитория?

git fetch origin --tags test-build-1

git fetch origin test-build-1

git checkout test-build-1

git pull --tags
V **git fetch origin tag test-build-1**


**Команда разработчиков протестировала новую подсистему логирования, включенную в проект в трех последовательных коммитах:**
9fcb1d3 (HEAD → main) Added log rotation logic
a3be8e9 Integrated new structured logging format
7a5c4f1 Introduced basic logging infrastructure

На продакшене выяснилось, что эта подсистема приводит к утечке памяти и блокировкам. Было принято решение полностью откатить все связанные изменения, сохранив остальные коммиты в истории. При этом:

Коммиты логирования идут подряд.

Другие команды уже создали feature-ветки от HEAD.

Ветка main активно используется, и force-push нежелателен.

Команда хочет сохранить историю изменений (а не переписать ее).

Какой способ подходит для этого случая?

Выполнить git rebase -i и удалить указанные коммиты — затем форсировать пуш
V **Выполнить git revert 7a5c4f1..9fcb1d3 — создаст обратные коммиты для всей группы**

Выполнить git cherry-pick всех коммитов, кроме логирования в новую ветку, и заменить ею main

Использовать git reset --hard 7a5c4f1^ и заново закоммитить только нужные изменения

Создать новую ветку от 7a5c4f1^, внести исправления вручную и сделать force-push в main


**В процессе интерактивного rebase вы видите следующее в редакторе:**
1 pick a1b2c3 First commit
2 pick d4e5f6 Second commit
3 pick 789abc Third commit

Вы хотите, чтобы Second commit стал последним. Как должен выглядеть новый порядок?

1 edit a1b2c3 First commit
2 squash d4e5f6 Second commit
3 pick 789abc Third commit

1 pick 789abc Third commit
2 pick d4e5f6 Second commit
3 pick a1b2c3 First commit

1 drop d4e5f6 Second commit
2 pick a1b2c3 First commit
3 pick 789abc Third commit

1 pick d4e5f6 Second commit
2 pick a1b2c3 First commit
3 pick 789abc Third commit

V **1 pick a1b2c3 First commit**
  **2 pick 789abc Third commit**
  **3 pick d4e5f6 Second commit**