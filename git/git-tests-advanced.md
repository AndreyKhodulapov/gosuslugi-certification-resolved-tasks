**Команда разработчиков решила хранить большие бинарные файлы (изображения, видео и 3D-модели) в репозитории Git. Все изменения в них фиксируются напрямую в коммитах.**

**Репозиторий уже содержит 2 ГБ исходного кода и документации. Ежедневно добавляется около 200 МБ новых бинарных файлов с незначительными изменениями.**

**Оцените, насколько правильно использовать Git в таком сценарии, и объясните, как это повлияет на производительность и размер репозитория в долгосрочной перспективе.**

Это допустимо при условии регулярного выполнения git gc --aggressive для оптимизации хранилища объектов и удаления избыточных данных
Это некорректно, так как Git не умеет работать с файлами в кодировке, отличной от UTF-8
Это допустимо, если использовать shallow clone с глубиной не более 10 коммитов при работе с репозиторием: тогда операции будут достаточно быстрыми
V **Это некорректно: Git будет сохранять полные копии файлов при каждом изменении, это приведет к росту размера репозитория и замедлению операций**
Это нормальная практика: Git использует дельта-сжатие для всех типов файлов, поэтому размер репозитория будет расти линейно, а не экспоненциально


**Вы с коллегой работаете над новой функциональностью в API в ветке feature/api-implementation. В ветку main было внесено несколько исправлений ошибок, которые также присутствуют в вашей ветке. Однако в main есть и другие изменения, несовместимые с вашей текущей веткой. Ваш коллега выполнил действия для исправления этих ошибок в вашей ветке, не затрагивая остальные функции.**

Определите по текущему и предыдущему состояниям веток, какую последовательность команд выполнил ваш коллега.

Учтите: он точно не копировал изменения в вашу ветку вручную и не создавал новых коммитов с нуля.

Состояние ветки feature/api-implementation до изменений

80a8cf6: New api implementation
Изменения в файлах: api.js, models.js
1c69684: V2
Изменения в файлах: config.js, utils.js
99a9c09: V1
Изменения в файлах: index.js, package.json

Состояние ветки main

f7d21e: UI improvements
Изменения в файлах: ui.js, styles.css
d5bb6ba: V3
Изменения в файлах: config.js, database.js
e3a91c2: Security fix
Изменения в файлах: auth.js, api.js
c1e97f1: API hot-fix
Изменения в файлах: api.js
b2d83f4: Performance optimization
Изменения в файлах: utils.js, models.js
1c69684: V2
Изменения в файлах: config.js, utils.js
99a9c09: V1
Изменения в файлах: index.js, package.json

Текущее состояние ветки feature/api-implementation

7ae290f: Security fix
Изменения в файлах: auth.js, api.js
4fde353: API hot-fix
Изменения в файлах: api.js
2b8c1a5: Performance optimization
Изменения в файлах: utils.js, models.js
30a8cf6: New api implementation
Изменения в файлах: api.js, models.js
1c69684: V2
Изменения в файлах: config.js, utils.js
99a9c09: V1
Изменения в файлах: index.js, package.json

git format-patch main --stdout | git apply --reject && git commit -am "Apply fixes from main"
git rebase -i main --onto <hash>
V **git cherry-pick b2d83f4 c1e97f1 e3a91c2**
git checkout main api.js auth.js utils.js models.js && git commit -m "Apply fixes from main"
git merge main && git revert <hash>


**Вы работаете над проектом и замечаете, что изменения, которые касаются исправления ошибки в форме в ветке feature/data-form, исчезли, хотя раньше они точно были.**

Вы выполняете команду git log и видите следующий вывод:

1 commit 1c69684
2 Author: Some Developer
3 Date: Mon Dec 18 10:00:00 2024
4 Initial implementation of form functionality

1 commit 5f62b1c
2 Author: Some Developer
3 Date: Mon Dec 9 18:30:00 2024
4 Added database connection

После этого вы выполняете команду git reflog, чтобы посмотреть журнал операций с объектами в Git, и видите такой вывод:

1 5f62b1c HEAD@{0}: reset: moving to HEAD~1
2 a2f3143 HEAD@{1}: commit: Fix for form functionality
3 5f62b1c HEAD@{2}: commit: Initial implementation of form functionality

Какая команда была выполнена и какую команду теперь надо выполнить, чтобы восстановить ваши изменения?

Выполнена git reset --mixed, которая удалила коммит a2f3143 и оставила изменения в рабочей директории, а для восстановления надо выполнить git commit
Выполнена git revert, отменившая изменения из коммита a2f3143, а для восстановления надо выполнить git revert HEAD
V **Выполнена git reset --hard, которая удалила коммит a2f3143, а для восстановления надо выполнить git cherry-pick a2f3143**
Выполнена git reset --soft, которая удалила коммит a2f3143 и перенесла изменения в staging area, а для восстановления надо выполнить git commit
Выполнена git rebase, из-за которой коммит a2f3143 был потерян, а для восстановления надо выполнить git stash pop


**Вы работаете в ветке feature/new-customer-model, которая была создана командой git checkout -b feature/new-customer-model. После завершения разработки вы пытаетесь отправить изменения в удаленный репозиторий origin и выполняете команду git push origin.**

Какой результат вы получите и почему?

Команда завершится с ошибкой, так как перед push необходимо подписать коммиты с помощью git push -s
Команда успешно завершится, а в удаленном репозитории будет создана новая ветка
Команда завершится успешно, но с предупреждением о том, что была создана новая ветка
V **Команда завершится с ошибкой, так как локальная ветка еще не связана с удаленным репозиторием**
Команда завершится с ошибкой, так как origin не может быть именем удаленного репозитория


**Вы работаете в команде, использующей расширенную методологию Git Flow с дополнительными типами веток. Ваш проект имеет следующую структуру веток:**

main (стабильные релизы)
develop (текущая разработка)
release/* (подготовка релизов)
hotfix/* (срочные исправления)
feature/* (новые функции)
experimental/* (экспериментальные функции)
refactor/* (рефакторинг кода)
Один из ваших коллег выполнил следующие действия:

Создал ветку refactor/db-constraints от develop
Сделал в ней 15 небольших коммитов, каждый из которых рефакторит отдельную часть кода БД
Выполнил слияние ветки refactor/db-constraints в develop командой: git merge --squash refactor/db-constraints
Создал новый коммит в develop с подробным описанием всех изменений
Не удалил ветку refactor/db-constraints после слияния
Какой из следующих выводов отражает последствия таких действий с точки зрения расширенного Git Flow и управления историей изменений?

Не соответствует, так как после слияния с флагом --squash ветка refactor/db-constraints должна быть немедленно удалена, потому что ее история больше не имеет значения
Не соответствует, так как ветки refactor/* не предусмотрены в стандартной Git Flow, их следовало оформить как feature/*
Полностью не соответствует, так как в Git Flow всегда требуется использовать стандартное слияние (git merge --no-ff) для сохранения всей истории изменений, включая промежуточные коммиты даже для веток рефакторинга
Частично соответствует, но коллега должен был использовать git rebase перед слиянием, чтобы создать линейную историю, а затем выполнить fast forward merge
V **Соответствует для веток рефакторинга, так как объединение множества мелких изменений в один логический коммит с помощью --squash упрощает историю develop, при этом полная детализация изменений остается доступной в исходной ветке**


**Вы обнаружили ошибку в текущей версии проекта и хотите использовать команду git bisect для поиска коммита, который создал эту ошибку.**

Вы знаете, что ошибка не воспроизводится в коммите с хешем 99a9c09, а хеш коммита текущей версии проекта — c1e97f1.

Какую команду надо выполнить для начала работы с git bisect?

git bisect bad c1e97f1
git bisect good 99a9c09
git bisect start 99a9c09 c1e97f1
V **git bisect start c1e97f1 99a9c09**
git bisect reset


**Для чего используется Git Submodules?**

Для объединения нескольких репозиториев в один, чтобы они работали как единое целое
Для синхронизации версий файлов между несколькими проектами
Для удаления веток из другого репозитория
Для работы с несколькими независимыми репозиториями в одном проекте
V **Для отслеживания изменений в другом репозитории как части вашего текущего проекта.**


**Объясните, как технически работает Git LFS и какие преимущества он предоставляет по сравнению со стандартным Git при работе с большими файлами.**

Git LFS позволяет подключать внешнее хранилище через Git remote и хранить большие файлы отдельно от основного репозитория, но с теми же идентификаторами коммитов
Git LFS автоматически разбивает большие файлы на фрагменты и хранит только изменившиеся фрагменты при каждом коммите, это позволяет эффективно отслеживать изменения в бинарных файлах
V **Git LFS заменяет большие файлы в репозитории на текстовые указатели (pointer files), содержащие SHA-256 хеш и метаданные, а сами файлы хранятся на отдельном LFS-сервере, это ускоряет операции клонирования и извлечения**
Git LFS создает отдельный репозиторий для больших файлов и автоматически синхронизирует его с основным репозиторием при выполнении команд push и pull, это уменьшает размер основного репозитория
Git LFS использует специальный алгоритм сжатия для больших файлов, который эффективнее стандартного алгоритма Git, это позволяет хранить большие файлы с меньшими затратами дискового пространства


**Ваш коллега, работая над коммитами в ветке main, заметил: история коммитов в ней содержит коммит 3256012 с очень большим файлом debug.log и другими изменениями. Этот файл уже удален из репозитория в коммите 8dd9645, но всё еще существует в истории и усложняет работу с репозиторием. Он выполнил какую-то операцию с деревом коммитов и удалил этот файл из всех предыдущих коммитов.**

Начальное состояние ветки (вывод git log --oneline):

1 f1fe759 (HEAD -> main) Fixed documentation and comments
2 8dd9645 Removed debug.log
3 c6efbed Finished main feature
4 325b012 Added model implementation
5 e21d3cc Initial commit

Итоговое состояние ветки (вывод git log --oneline):

1 62db399 (HEAD -> main) Fixed documentation and comments
2 af98fe5 Removed debug.log
3 f7048f0 Finished main feature
4 4d1dde5 Added model implementation
5 e21d3cc Initial commit

Какую операцию из перечисленных выполнил ваш коллега?

Выполнил git cherry-pick для удаления файла и пересоздал коммиты вручную
Выполнил git filter-branch --tree-filter "rm -f debug.log" --all
Выполнил git commit --amend, удалив файл вручную, а затем перезаписал историю командой git push --force
V **Выполнил git filter-branch --index-filter "git rm --cached debug.log" --all**
Выполнил git rebase -i для редактирования коммита и удаления файла


**Какой из следующих подходов наиболее эффективен для интеграции внешнего репозитория, когда требуется сохранить полную историю изменений внешнего проекта и иметь возможность вносить локальные изменения, не затрагивая основной репозиторий?**

Копирование файлов вручную и добавление их в .gitignore
Использование git subtree с опцией --squash
Использование git submodule с настройкой shallow clone
Использование git submodule с последующим форком подмодуля
V **Использование git subtree без опции squash**


**Разработчик случайно выполнил git reset --hard HEAD~3, удалив последние три коммита, которые еще не были отправлены в удаленный репозиторий.**

Какая последовательность команд позволит восстановить потерянные коммиты и создать новую ветку с этими изменениями?

V **1 git reflog**
  **2 git reset --hard HEAD@{3}**
  **3 git checkout -b recovery-branch**

1 git reflog show
2 git checkout HEAD@{3}
3 git checkout -b recovery-branch

1 git log --graph --all
2 git checkout <commit>
3 git checkout -b recovery

1 git log --all
2 git cherry-pick <commit-hash>
3 git push origin recovery-branch

1 git fsck --lost-found
2 git merge ORIG_HEAD
3 git branch recovery-branch


**В вашей компании используется CI/CD-система, которая автоматически развертывает приложение на основе Git-тегов. Вам необходимо создать новый релиз v2.5.0, который должен соответствовать следующим требованиям:**

Тег должен содержать подробное описание изменений в релизе.
Тег должен быть создан для определенного коммита с хешем a7d3f1c, а не для HEAD.
Тег должен быть доступен всем разработчикам через удаленный репозиторий.
В системе должна сохраниться информация о том, кто и когда создал этот тег.
Какая последовательность команд Git корректно выполнит все эти требования?

git checkout a7d3f1c && git tag v2.5.0 && git push origin v2.5.0
git tag -a version2.5.0 a7d3f1c -m "Release v2.5.0" && git push origin version2.5.0
git checkout a7d3f1c && git tag -s v2.5.0 -m "Release v2.5.0" && git push --tags
git tag -s v2.5.0 a7d3f1c -m "Release v2.5.0" && git push --follow-tags
V **it tag -a v2.5.0 a7d3f1c -m "Release v2.5.0" && git push origin v2.5.0**


**Вы работаете над сложным проектом и сталкиваетесь со следующей ситуацией:**

В ветке feature/auth вы внесли изменения в несколько файлов, часть из которых уже добавлена в индекс (staged).
Вам срочно нужно переключиться на ветку hotfix/security для исправления критической уязвимости.
Вы хотите сохранить только изменения в файлах, связанных с аутентификацией (auth*.js), но отбросить остальные изменения.
После завершения работы над hotfix вам нужно вернуться к работе над аутентификацией и восстановить только сохраненные изменения.
Вы хотите сохранить изменения локально, не отправляя их в удаленный репозиторий.

Какая из последовательностей команд Git позволит выполнить все эти действия?

1 git stash
2 git checkout hotfix/security
3 [работа над hotfix]
4 git checkout feature/auth
5 git stash pop

1 git stash push -m "auth changes" auth.js
2 git checkout hotfix/security
3 [работа над hotfix]
4 git checkout feature/auth
5 git stash pop

V **1 git add auth*.js**
  **2 git stash**
  **3 git reset hard**
  **4 git checkout hotfix/security**
  **5 [работа над hotfix]**
  **6 git checkout feature/auth**
  **7 git stash apply**

1 git stash save "auth changes"
2 git checkout hotfix/security
3 [работа над hotfix]
4 git checkout feature/auth
5 git stash apply stash@{0}

1 git commit -am "WIP: auth changes"
2 git checkout hotfix/security
3 [работа над hotfix]
4 git checkout feature/auth
5 git reset HEAD~1


**В проекте с микросервисной архитектурой обнаружена критическая уязвимость безопасности, внесенная коммитом abc123 два месяца назад. Этот коммит затрагивает общую библиотеку аутентификации, используемую во всех сервисах. Ситуация осложняется следующими факторами:**

После проблемного коммита было сделано более 200 коммитов в основной ветке.
От основной ветки было создано пять релизных веток, в которых также есть этот коммит.
Несколько команд разработчиков создали feature-ветки от разных точек истории.
Некоторые последующие коммиты в основной ветке частично исправляют проблему, но не полностью.
Все затронутые ветки уже развернуты в различных средах (тестовой, препродакшен, продакшен).
Какая стратегия будет эффективной для устранения уязвимости во всех ветках с минимальным риском нарушения работы проекта?

Создать hotfix-ветку от точки до проблемного коммита, внести исправления и выполнить слияние этой ветки со всеми затронутыми ветками
Использовать git rebase -i для редактирования проблемного коммита в каждой ветке, с последующим принудительным обновлением (force-push)
Использовать git bisect для точного определения проблемного кода, создать патч и применить его ко всем веткам с помощью git am
V **Создать единый исправляющий коммит с помощью git revert abc123 в основной ветке и затем выполнить cherry-pick этого коммита во все релизные ветки**
Создать серию revert-коммитов для проблемного коммита и всех коммитов, которые частично его исправляли, затем создать новый коммит с полным исправлением


**Вы работаете над проектом. В ветке feature/mvp у вас есть несколько коммитов, и вы хотите исправить последние три коммита, включая текущий.**

В одном из них есть ошибка, которую вы хотите исправить, а в другом неудачное название.

Вы хотите изменить порядок коммитов, исправить ошибку и изменить название коммита, чтобы улучшить историю проекта перед push изменений в основную ветку.

Какую команду в Git надо использовать, чтобы выполнить всё это в интерактивном режиме?

git reset -i HEAD~3
git merge --no-ff feature/mvp
V **git rebase -i HEAD~3**
git cherry-pick HEAD~3
git pull --rebase -i HEAD~3