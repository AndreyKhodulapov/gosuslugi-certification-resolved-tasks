STATUS: решение проверено публичными тестами

**Максимальный средний вес товара**
Описание:
Вы — аналитик в агентстве. Крупный ритейлер заказал у вашего агентства исследование среднего веса приобретаемых фруктов для оптимизации закупок и изучения поведения покупателей в зависимости от типа торговой точки.

Посчитайте средний вес каждого товара по торговым точкам. Определите максимальный средний вес каждого товара и магазин, в котором он был зафиксирован.

Формат ввода:
Таблица giper_market:

item (string) — название товара
weight (float) — средний вес товара
Таблица local_market:

item (string) — название товара
weight (float) — средний вес товара
Таблица super_market:

item (string) — название товара
weight (float) — средний вес товара
Данные не содержат пропусков или некорректных значений. Во всех магазинах изучаемый ассортимент идентичный.

Формат вывода:
Запрос должен вернуть таблицу со следующими полями:

item (string) — название товара
max_avg_weight (float) — максимальный средний вес, округленный до 2 знаков после запятой
shop (string) — название магазина, в котором был посчитан максимальный средний вес товара
Таблица должна быть отсортирована по item и shop.

Код:

CREATE TABLE giper_market (
item  TEXT NOT NULL,
weight  FLOAT NOT NULL
);
CREATE TABLE local_market (
item  TEXT NOT NULL,
weight  FLOAT NOT NULL
);
CREATE TABLE super_market (
item  TEXT NOT NULL,
weight  FLOAT NOT NULL
);

INSERT INTO giper_market (item, weight) VALUES 
('арбуз', 3781.19),
('лимон', 1769.23),
('яблоко', 3435.11),
('банан', 2611.26),
('дыня', 2233.21);
INSERT INTO local_market (item, weight) VALUES 
('банан', 3006.65),
('банан', 1443.08),
('яблоко', 1764.49),
('арбуз', 2855.19),
('яблоко', 800.58);
INSERT INTO super_market (item, weight) VALUES 
('персик', 1379.38),
('виноград', 2313.62),
('яблоко', 338.91),
('арбуз', 5490.58),
('арбуз', 7268.54);

**РЕШЕНИЕ:**
WITH all_markets AS (
    SELECT item, weight, 'giper_market' as shop FROM giper_market
    UNION ALL
    SELECT item, weight, 'local_market' as shop FROM local_market
    UNION ALL
    SELECT item, weight, 'super_market' as shop FROM super_market
),
avg_weights AS (
    SELECT 
        item,
        shop,
        ROUND(AVG(weight), 2) as avg_weight
    FROM all_markets
    GROUP BY item, shop
),
max_weights AS (
    SELECT 
        item,
        MAX(avg_weight) as max_avg_weight
    FROM avg_weights
    GROUP BY item
)
SELECT 
    a.item,
    m.max_avg_weight,
    a.shop
FROM avg_weights a
JOIN max_weights m ON a.item = m.item AND a.avg_weight = m.max_avg_weight
ORDER BY a.item, a.shop;

**AЛЬТЕРНАТИВНОЕ РЕШЕНИЕ С ОКОННОЙ ФУНКЦИЕЙ**
WITH all_markets AS (
    SELECT item, weight, 'giper_market' as shop FROM giper_market
    UNION ALL
    SELECT item, weight, 'local_market' as shop FROM local_market
    UNION ALL
    SELECT item, weight, 'super_market' as shop FROM super_market
),
avg_weights AS (
    SELECT 
        item,
        shop,
        ROUND(AVG(weight), 2) as avg_weight,
        RANK() OVER (PARTITION BY item ORDER BY AVG(weight) DESC) as rnk
    FROM all_markets
    GROUP BY item, shop
)
SELECT 
    item,
    avg_weight as max_avg_weight,
    shop
FROM avg_weights
WHERE rnk = 1
ORDER BY item, shop;

РЕЗУЛЬТАТЫ ЗАПРОСОВ:
item	max_avg_weight	shop
арбуз	6383.56	super_market
банан	3006.65	local_market
виноград	2313.62	super_market
дыня	2233.21	giper_market
лимон	1769.23	giper_market
персик	1379.38	super_market
яблоко	3435.11	giper_market


STATUS: решение проверено публичными тестами

**Доля трафиков от ботов**
Описание:
Команда антифрода разработала механизм определения трафика от ботов на сайт магазина: при входе бота на сайт в параметры его URL добавляется параметр type=bot. Но из-за периодического падения сервера с системой мониторинга в параметр type у ботов иногда ставится не bot, а нижнее подчеркивание.

Тем не менее, иногда ботам удается обмануть систему мониторинга и отметка bot не попадает в url. В этом случае бота можно идентифицировать по user_id (если user_id хотя бы один раз был определен как бот, то он всегда должен определяться как бот).

Изучите данные с визитами пользователей на сайт и посчитайте долю ботов от общего числа пользователей в декабре. При определении ботов учитывайте, что если user_id хотя бы один раз был определен как бот, то он всегда должен определяться как бот.

Формат ввода:
Таблица events:

event_date (date) — дата визита
user_id (int) — уникальный идентификатор пользователя
url (string) — ссылка, по которой был осуществлен переход
Данные не содержат пропусков или некорректных значений.

Формат вывода:
Запрос должен вернуть таблицу с полями:

share (float) — доля ботов от общего числа пользователей в декабре, округленная до одного знака после запятой.
Код:

CREATE TABLE events (
    event_date DATE NOT NULL,
    user_id INT NOT NULL,
    url VARCHAR(255) NOT NULL
);

INSERT INTO events (event_date, user_id, url) VALUES
('2024-12-01', 1, 'https://my_website.com/home?type=user&dt=2024-12-01'),
('2024-12-01', 2, 'https://my_website.com/home?type=bot&dt=2024-12-01'),
('2024-12-15', 3, 'https://my_website.com/home?type=user&dt=2024-11-30'),
('2024-12-31', 4, 'https://my_website.com/home?type=bot&dt=2024-12-31'),
('2024-12-05', 5, 'https://my_website.com/home?type=bot&dt=2024-12-05');

**РЕШЕНИЕ**
WITH december_users AS (
    -- Все уникальные пользователи за декабрь
    SELECT DISTINCT user_id
    FROM events
    WHERE EXTRACT(MONTH FROM event_date) = 12
),
bot_users AS (
    -- Пользователи, которые хотя бы раз были определены как боты
    SELECT DISTINCT user_id
    FROM events
    WHERE url LIKE '%type=bot%' OR url LIKE '%type=_%'
)
SELECT 
    ROUND(
        COUNT(DISTINCT b.user_id) * 100.0 / COUNT(DISTINCT d.user_id),
        1
    ) as share
FROM december_users d
LEFT JOIN bot_users b ON d.user_id = b.user_id;

**AЛЬТЕРНАТИВНОЕ РЕШЕНИЕ С ОКОННОЙ ФУНКЦИЕЙ**
WITH bot_identification AS (
    SELECT 
        user_id,
        MAX(CASE WHEN url LIKE '%type=bot%' OR url LIKE '%type=_%' THEN 1 ELSE 0 END) as is_bot
    FROM events
    WHERE EXTRACT(MONTH FROM event_date) = 12
    GROUP BY user_id
)
SELECT 
    ROUND(
        SUM(is_bot) * 100.0 / COUNT(*),
        1
    ) as share
FROM bot_identification;

Проверка на тестовых данных:
На предоставленных данных:
Все пользователи за декабрь: 1, 2, 3, 4, 5
Боты: 2 (type=bot), 4 (type=bot), 5 (type=bot)
Доля ботов: 3/5 = 60.0%
Оба запроса вернут результат: 60.0


STATUS: решение проверено публичными тестами
**База для рассылки**

Описание:
Вы — продуктовый аналитик онлайн-кинотеатра. Вам нужно отобрать всех активных клиентов, которые были подписаны хотя бы год (то есть с 2024-01-01 по 2024-12-01), для отправки маркетинговой рассылки. Клиенты должны быть активными, то есть на момент формирования отчета (2024-12-01) их подписка должна быть активна, а также средняя длина их сессии за последние 6 месяцев должна быть более 35 минут.

Используйте вложенные запросы в решении.

Формат ввода:
Таблица deals:

client_id (int) — уникальный идентификатор покупателя
purchase_date (date) — дата приобретения подписки
Таблица subscribers:

client_id (int) — уникальный идентификатор покупателя
min_sub_date (date) — дата первого приобретения подписки
max_sub_date (date) — дата окончания действия подписки
Таблица sessions:

client_id (int) — уникальный идентификатор покупателя
session_start (datetime) — дата начала сессии
session_end (datetime) — дата окончания сессии
Данные не содержат пропусков, дубликатов или некорректных значений.

Формат вывода:
Запрос должен вернуть таблицу со следующими полями:

client_id (int) — уникальный идентификатор покупателя
Выходные данные отсортированы по возрастанию client_id, как и входная таблица.

Код:

CREATE TABLE deals (
client_id  INT NOT NULL,
purchase_date  TIMESTAMP NOT NULL
);
CREATE TABLE subscribers (
client_id  INT NOT NULL,
min_sub_date TIMESTAMP NOT NULL,
max_sub_date TIMESTAMP NOT NULL
);
CREATE TABLE sessions (
client_id INT NOT NULL,
session_start TIMESTAMP NOT NULL,
session_end TIMESTAMP NOT NULL
);

INSERT INTO deals (client_id, purchase_date) VALUES 
(102, '2024-10-01'),
(103, '2024-09-01'),
(103, '2024-10-01'),
(103, '2024-11-01'),
(108, '2024-02-01'),
(106, '2024-10-01'),
(108, '2024-10-01'),
(102, '2024-03-01'),
(108, '2024-11-01'),
(101, '2024-11-01'),
(106, '2024-11-01'),
(105, '2024-11-01'),
(103, '2024-05-01'),
(100, '2024-03-01'),
(101, '2024-03-01'),
(110, '2024-01-01'),
(105, '2024-09-01'),
(100, '2024-05-01'),
(107, '2024-09-01'),
(102, '2024-02-01'),
(108, '2024-01-01'),
(100, '2024-06-01'),
(110, '2024-12-01'),
(100, '2024-12-01'),
(103, '2024-06-01'),
(110, '2024-03-01'),
(101, '2024-07-01'),
(102, '2024-09-01'),
(106, '2024-03-01'),
(104, '2024-05-01'),
(106, '2024-01-01'),
(101, '2024-01-01'),
(101, '2024-02-01'),
(105, '2024-08-01'),
(104, '2024-08-01'),
(108, '2024-05-01'),
(104, '2024-04-01'),
(108, '2024-07-01'),
(108, '2024-04-01'),
(109, '2024-08-01'),
(110, '2024-04-01'),
(109, '2024-10-01'),
(106, '2024-12-01'),
(104, '2024-01-01'),
(104, '2024-03-01'),
(107, '2024-12-01'),
(108, '2024-06-01'),
(100, '2024-02-01'),
(102, '2024-07-01'),
(101, '2024-08-01'),
(105, '2024-04-01'),
(107, '2024-01-01'),
(102, '2024-01-01'),
(101, '2024-05-01'),
(103, '2024-01-01'),
(107, '2024-02-01'),
(108, '2024-09-01'),
(104, '2024-07-01'),
(105, '2024-03-01'),
(101, '2024-06-01'),
(100, '2024-09-01'),
(103, '2024-03-01'),
(106, '2024-07-01'),
(107, '2024-05-01'),
(109, '2024-05-01'),
(109, '2024-11-01'),
(106, '2024-04-01'),
(109, '2024-04-01'),
(108, '2024-12-01'),
(103, '2024-02-01'),
(109, '2024-09-01'),
(105, '2024-02-01'),
(104, '2024-12-01'),
(107, '2024-06-01'),
(104, '2024-06-01'),
(106, '2024-02-01'),
(102, '2024-06-01'),
(109, '2024-02-01'),
(107, '2024-04-01'),
(110, '2024-11-01'),
(105, '2024-06-01'),
(104, '2024-02-01'),
(102, '2024-11-01'),
(104, '2024-10-01'),
(110, '2024-07-01'),
(101, '2024-10-01'),
(106, '2024-05-01'),
(110, '2024-10-01'),
(102, '2024-05-01'),
(109, '2024-03-01'),
(106, '2024-06-01'),
(101, '2024-04-01'),
(101, '2024-12-01'),
(101, '2024-09-01'),
(109, '2024-06-01'),
(100, '2024-04-01'),
(108, '2024-03-01'),
(107, '2024-10-01'),
(103, '2024-07-01'),
(105, '2024-12-01'),
(110, '2024-08-01'),
(104, '2024-11-01'),
(102, '2024-04-01'),
(100, '2024-11-01'),
(107, '2024-03-01'),
(103, '2024-08-01'),
(107, '2024-07-01'),
(102, '2024-12-01'),
(100, '2024-08-01'),
(105, '2024-10-01'),
(110, '2024-02-01'),
(109, '2024-07-01'),
(103, '2024-04-01');

INSERT INTO subscribers (client_id, min_sub_date, max_sub_date) VALUES 
(100, '2024-02-01', '2024-12-01'),
(101, '2024-01-01', '2024-12-01'),
(102, '2024-01-01', '2024-12-01'),
(103, '2024-01-01', '2024-11-01'),
(104, '2024-01-01', '2024-12-01'),
(105, '2024-02-01', '2024-12-01'),
(106, '2024-01-01', '2024-12-01'),
(107, '2024-01-01', '2024-12-01'),
(108, '2024-01-01', '2024-12-01'),
(109, '2024-02-01', '2024-11-01'),
(110, '2024-01-01', '2024-12-01');

INSERT INTO sessions (client_id, session_start, session_end) VALUES 
(106, '2024-12-08 17:45:28', '2024-12-08 18:32:57'),
(100, '2024-12-04 22:16:18', '2024-12-04 22:20:30'),
(109, '2024-12-06 21:47:56', '2024-12-06 22:49:38'),
(109, '2024-12-24 09:21:00', '2024-12-24 10:21:18'),
(110, '2024-12-07 17:43:02', '2024-12-07 19:22:01'),
(101, '2024-12-16 23:38:23', '2024-12-17 01:09:24'),
(102, '2024-12-15 21:05:12', '2024-12-15 22:06:59'),
(101, '2024-12-21 16:36:49', '2024-12-21 17:34:36'),
(101, '2024-12-03 03:32:38', '2024-12-03 04:30:14'),
(110, '2024-12-10 19:12:56', '2024-12-10 19:55:27'),
(104, '2024-12-24 17:35:23', '2024-12-24 18:50:54'),
(101, '2024-12-17 21:09:29', '2024-12-17 21:40:53'),
(100, '2024-12-01 21:11:48', '2024-12-01 21:29:16'),
(101, '2024-12-09 20:06:03', '2024-12-09 21:56:46'),
(110, '2024-12-17 22:30:42', '2024-12-18 00:21:21'),
(102, '2024-12-01 20:37:48', '2024-12-01 22:01:15'),
(106, '2024-12-21 13:57:17', '2024-12-21 14:32:39'),
(104, '2024-12-12 01:41:22', '2024-12-12 02:53:35'),
(102, '2024-12-02 15:47:27', '2024-12-02 17:25:16'),
(100, '2024-12-04 11:50:48', '2024-12-04 12:32:23'),
(106, '2024-12-26 12:55:35', '2024-12-26 14:41:14'),
(108, '2024-12-02 20:33:24', '2024-12-02 20:55:16'),
(109, '2024-12-16 04:45:44', '2024-12-16 05:51:15'),
(101, '2024-12-13 21:19:37', '2024-12-13 21:59:51'),
(109, '2024-12-21 08:21:02', '2024-12-21 09:00:49'),
(106, '2024-12-03 03:12:51', '2024-12-03 03:44:51'),
(109, '2024-12-15 08:41:53', '2024-12-15 10:12:47'),
(102, '2024-12-27 11:04:12', '2024-12-27 11:44:24'),
(105, '2024-12-19 06:25:53', '2024-12-19 08:20:04'),
(103, '2024-12-09 13:16:04', '2024-12-09 13:40:07'),
(100, '2024-12-31 17:07:15', '2024-12-31 18:34:14'),
(105, '2024-12-27 20:23:37', '2024-12-27 20:44:42'),
(103, '2024-12-10 18:05:09', '2024-12-10 18:45:47'),
(107, '2024-12-12 08:19:23', '2024-12-12 10:16:20'),
(101, '2024-12-15 06:20:00', '2024-12-15 07:55:12'),
(108, '2024-12-11 19:25:58', '2024-12-11 21:10:46'),
(109, '2024-12-19 21:45:54', '2024-12-19 22:54:06'),
(108, '2024-12-11 06:43:25', '2024-12-11 06:50:58'),
(104, '2024-12-29 11:00:26', '2024-12-29 11:44:27'),
(110, '2024-12-20 13:18:04', '2024-12-20 14:25:38'),
(102, '2024-12-06 17:00:09', '2024-12-06 18:25:56'),
(101, '2024-12-30 14:50:45', '2024-12-30 15:00:03'),
(102, '2024-12-20 01:07:03', '2024-12-20 01:14:43'),
(108, '2024-12-23 03:38:48', '2024-12-23 05:02:48'),
(100, '2024-12-03 08:22:09', '2024-12-03 09:18:00'),
(107, '2024-12-19 17:13:25', '2024-12-19 18:50:36'),
(100, '2024-12-05 17:22:52', '2024-12-05 18:55:30'),
(107, '2024-12-27 19:25:25', '2024-12-27 21:09:14'),
(100, '2024-12-07 10:19:56', '2024-12-07 11:01:23'),
(108, '2024-12-25 02:09:10', '2024-12-25 02:18:58');

**РЕШЕНИЕ**
SELECT DISTINCT client_id
FROM (
    SELECT client_id
    FROM subscribers
    WHERE max_sub_date >= '2024-12-01'
      AND min_sub_date <= '2024-01-01'
) AS active_subs
WHERE client_id IN (
    SELECT client_id
    FROM (
        SELECT 
            client_id,
            AVG(
                -- Универсальный способ вычисления минут
                (JULIANDAY(session_end) - JULIANDAY(session_start)) * 24 * 60
            ) AS avg_session_minutes
        FROM sessions
        WHERE session_start >= '2024-06-01'
          AND session_start < '2024-12-01'
        GROUP BY client_id
        HAVING AVG(
            (JULIANDAY(session_end) - JULIANDAY(session_start)) * 24 * 60
        ) > 35
    ) AS active_users
)
ORDER BY client_id;

**РЕШЕНИЕ ПОД POSTGRES**
SELECT DISTINCT client_id
FROM (
    -- Клиенты с активной подпиской на 2024-12-01
    SELECT client_id
    FROM subscribers
    WHERE max_sub_date >= '2024-12-01'
      AND min_sub_date <= '2024-01-01'
) AS active_subs
WHERE client_id IN (
    -- Клиенты со средней длиной сессии > 35 минут за последние 6 месяцев
    SELECT client_id
    FROM (
        SELECT 
            client_id,
            AVG(EXTRACT(EPOCH FROM (session_end - session_start)) / 60) AS avg_session_minutes
        FROM sessions
        WHERE session_start >= '2024-06-01'
          AND session_start < '2024-12-01'
        GROUP BY client_id
        HAVING AVG(EXTRACT(EPOCH FROM (session_end - session_start)) / 60) > 35
    ) AS active_users
)
ORDER BY client_id;

Ожидаемый результат:
client_id
101
102
104
106
107
108
110


STATUS: решение проверено публичными тестами
**Анализ эффекта удобрений**

Описание:
В рамках эксперимента ростом подсолнечника обрабатывали инновационными видами удобрений. Для оценки эффективности на соседнем поле высадили тот же сорт подсолнечника, только его обрабатывали обычным удобрением. Во время сбора урожая с каждого поля собрали по 500 подсолнечников и посчитали суммарный вес всех семян с каждого подсолнечника.

Рассчитайте t-критерий Стьюдента для каждого из типов удобрений и дайте ответ на вопрос, имеются ли статистически значимые отличия между группами А и В.

Формат ввода:
Таблица sunflowers_control:

sunflower_id (int) — уникальный идентификатор растения
seeds_weight (int) — вес семян растения в граммах
Таблица sunflowers_test1:

sunflower_id (int) — уникальный идентификатор растения
seeds_weight (int) — вес семян растения в граммах
Таблица sunflowers_test2:

sunflower_id (int) — уникальный идентификатор растения
seeds_weight (int) — вес семян растения в граммах
Таблица sunflowers_test3:

sunflower_id (int) — уникальный идентификатор растения
seeds_weight (int) — вес семян растения в граммах
Данные не содержат пропусков или некорректных значений.

Формат вывода:
Запрос должен вернуть таблицу с полями в таком порядке:

type (int) — тип удобрения
t_crit (float) — значение t-критерия, округленное до 2 знаков после запятой
diff (float) — разница средних весов тестовой и контрольной группы, округленная до 2 знаков после запятой
result (string) — флаг статистической значимости изменения
Таблица должна быть отсортирована по колонке type по возрастанию.

Код:

CREATE TABLE sunflowers_control (
sunflower_id  INT NOT NULL,
seeds_weight  INT NOT NULL
);
CREATE TABLE sunflowers_test1 (
sunflower_id  INT NOT NULL,
seeds_weight  INT NOT NULL
);
CREATE TABLE sunflowers_test2 (
sunflower_id  INT NOT NULL,
seeds_weight  INT NOT NULL
);
CREATE TABLE sunflowers_test3 (
sunflower_id  INT NOT NULL,
seeds_weight  INT NOT NULL
);

INSERT INTO sunflowers_test1 (sunflower_id, seeds_weight) VALUES 
(1, 348),
(2, 279),
(3, 289),
(4, 262),
(5, 315),
(6, 318),
(7, 336),
(8, 282),
(9, 272),
(10, 290),
(11, 328),
(12, 330),
(13, 334),
(14, 354),
(15, 295),
(16, 353),
(17, 315),
(18, 317),
(19, 338),
(20, 262),
(21, 291),
(22, 273),
(23, 293),
(24, 353),
(25, 307);

INSERT INTO sunflowers_test2 (sunflower_id, seeds_weight) VALUES 
(26, 339),
(27, 286),
(28, 310),
(29, 295),
(30, 268),
(31, 342),
(32, 331),
(33, 289),
(34, 346),
(35, 251),
(36, 352),
(37, 267),
(38, 273),
(39, 265),
(40, 310),
(41, 258),
(42, 296),
(43, 343),
(44, 284),
(45, 309),
(46, 263),
(47, 319),
(48, 280),
(49, 305),
(50, 281);

INSERT INTO sunflowers_test3 (sunflower_id, seeds_weight) VALUES 
(51, 302),
(52, 251),
(53, 322),
(54, 321),
(55, 304),
(56, 320),
(57, 335),
(58, 304),
(59, 296),
(60, 254),
(61, 298),
(62, 266),
(63, 313),
(64, 307),
(65, 259),
(66, 294),
(67, 335),
(68, 298),
(69, 266),
(70, 261),
(71, 334),
(72, 280),
(73, 289),
(74, 301),
(75, 297);

INSERT INTO sunflowers_control (sunflower_id, seeds_weight) VALUES 
(76, 297),
(77, 328),
(78, 350),
(79, 322),
(80, 252),
(81, 319),
(82, 266),
(83, 301),
(84, 313),
(85, 273),
(86, 288),
(87, 346),
(88, 340),
(89, 315),
(90, 344),
(91, 336),
(92, 250),
(93, 304),
(94, 318),
(95, 280),
(96, 304),
(97, 256),
(98, 261),
(99, 348);

**РЕШЕНИЕ**
Анализ эффекта удобрений
Описание:
В рамках эксперимента ростом подсолнечника обрабатывали инновационными видами удобрений. Для оценки эффективности на соседнем поле высадили тот же сорт подсолнечника, только его обрабатывали обычным удобрением. Во время сбора урожая с каждого поля собрали по 500 подсолнечников и посчитали суммарный вес всех семян с каждого подсолнечника.

Рассчитайте t-критерий Стьюдента для каждого из типов удобрений и дайте ответ на вопрос, имеются ли статистически значимые отличия между группами А и В.

Формат ввода:
Таблица sunflowers_control:

sunflower_id (int) — уникальный идентификатор растения
seeds_weight (int) — вес семян растения в граммах
Таблица sunflowers_test1:

sunflower_id (int) — уникальный идентификатор растения
seeds_weight (int) — вес семян растения в граммах
Таблица sunflowers_test2:

sunflower_id (int) — уникальный идентификатор растения
seeds_weight (int) — вес семян растения в граммах
Таблица sunflowers_test3:

sunflower_id (int) — уникальный идентификатор растения
seeds_weight (int) — вес семян растения в граммах
Данные не содержат пропусков или некорректных значений.

Формат вывода:
Запрос должен вернуть таблицу с полями в таком порядке:

type (int) — тип удобрения
t_crit (float) — значение t-критерия, округленное до 2 знаков после запятой
diff (float) — разница средних весов тестовой и контрольной группы, округленная до 2 знаков после запятой
result (string) — флаг статистической значимости изменения
Таблица должна быть отсортирована по колонке type по возрастанию.

Код:

CREATE TABLE sunflowers_control (
sunflower_id  INT NOT NULL,
seeds_weight  INT NOT NULL
);
CREATE TABLE sunflowers_test1 (
sunflower_id  INT NOT NULL,
seeds_weight  INT NOT NULL
);
CREATE TABLE sunflowers_test2 (
sunflower_id  INT NOT NULL,
seeds_weight  INT NOT NULL
);
CREATE TABLE sunflowers_test3 (
sunflower_id  INT NOT NULL,
seeds_weight  INT NOT NULL
);

INSERT INTO sunflowers_test1 (sunflower_id, seeds_weight) VALUES 
(1, 348),
(2, 279),
(3, 289),
(4, 262),
(5, 315),
(6, 318),
(7, 336),
(8, 282),
(9, 272),
(10, 290),
(11, 328),
(12, 330),
(13, 334),
(14, 354),
(15, 295),
(16, 353),
(17, 315),
(18, 317),
(19, 338),
(20, 262),
(21, 291),
(22, 273),
(23, 293),
(24, 353),
(25, 307);

INSERT INTO sunflowers_test2 (sunflower_id, seeds_weight) VALUES 
(26, 339),
(27, 286),
(28, 310),
(29, 295),
(30, 268),
(31, 342),
(32, 331),
(33, 289),
(34, 346),
(35, 251),
(36, 352),
(37, 267),
(38, 273),
(39, 265),
(40, 310),
(41, 258),
(42, 296),
(43, 343),
(44, 284),
(45, 309),
(46, 263),
(47, 319),
(48, 280),
(49, 305),
(50, 281);

INSERT INTO sunflowers_test3 (sunflower_id, seeds_weight) VALUES 
(51, 302),
(52, 251),
(53, 322),
(54, 321),
(55, 304),
(56, 320),
(57, 335),
(58, 304),
(59, 296),
(60, 254),
(61, 298),
(62, 266),
(63, 313),
(64, 307),
(65, 259),
(66, 294),
(67, 335),
(68, 298),
(69, 266),
(70, 261),
(71, 334),
(72, 280),
(73, 289),
(74, 301),
(75, 297);

INSERT INTO sunflowers_control (sunflower_id, seeds_weight) VALUES 
(76, 297),
(77, 328),
(78, 350),
(79, 322),
(80, 252),
(81, 319),
(82, 266),
(83, 301),
(84, 313),
(85, 273),
(86, 288),
(87, 346),
(88, 340),
(89, 315),
(90, 344),
(91, 336),
(92, 250),
(93, 304),
(94, 318),
(95, 280),
(96, 304),
(97, 256),
(98, 261),
(99, 348);

Ожидаемый результат:
type | t_crit | diff  | result
-----|--------|-------|-------
1    | -0.12  | -1.24 | no
2    | -0.82  | -8.44 | no
3    | -1.65  | -17.04| no

STATUS: решение проверено публичными тестами
**Премирование таксистов**

Премирование таксистов
Описание:
Под Новый год сервис для заказа такси хочет наградить таксистов, которые в декабре имели наивысшие оценки у клиентов и совершили наибольшее количество заказов.

Сформируйте рейтинг на основе этих двух параметров:

Вес оценок должен составлять 60%,
Вес количества поездок — 40%.
Примените к этим параметрам нормализацию. Также следует учесть, что для водителей разных тарифов действует надбавочный коэффициент:

Эконом — 0%
Комфорт — 10%
Бизнес — 20%
Из полученного списка отберите ТОП-10 сотрудников с наивысшим рейтингом. Если рейтинги сотрудников совпадают, премию получают все сотрудники с совпадающим рейтингом.

Формат ввода:
Таблица rides:

order_id (int) — уникальный идентификатор поездки
driver_id (int) — уникальный идентификатор водителя
start_ride (datetime) — дата и время начала поездки
end_ride (datetime) — дата и время конца поездки
rating (int) — рейтинг заказа от 1 до 5
Таблица tariffs:

driver_id (int) — уникальный идентификатор водителя
tariff (string) — тариф, по которому работает водитель
Данные не содержат пропусков или некорректных значений.

Формат вывода:
Запрос должен вернуть таблицу с полями:

driver_id (int) — уникальный идентификатор водителя
Выходная таблица отсортирована по возрастанию driver_id.

Код:

CREATE TABLE rides (
    order_id INT NOT NULL,
    driver_id INT NOT NULL,
    start_ride TIMESTAMP NOT NULL,
    end_ride TIMESTAMP NOT NULL,
    rating INT NOT NULL);
CREATE TABLE tariffs (
    driver_id INT NOT NULL,
    tariff TEXT NOT NULL);

INSERT INTO rides (order_id, driver_id, start_ride, end_ride, rating) VALUES 
(0, 25, '2025-01-06 00:11:19', '2025-01-06 00:14:19', 2),
(1, 25, '2025-01-29 02:36:33', '2025-01-29 03:15:33', 4),
(2, 7, '2024-12-19 09:55:23', '2024-12-19 10:06:23', 3),
(3, 9, '2024-11-29 02:23:47', '2024-11-29 03:01:47', 2),
(4, 28, '2025-01-29 20:07:40', '2025-01-29 20:39:40', 5),
(5, 7, '2024-11-14 16:46:47', '2024-11-14 17:27:47', 2),
(6, 29, '2024-12-01 23:21:42', '2024-12-01 23:43:42', 4),
(7, 49, '2025-01-09 21:46:07', '2025-01-09 21:50:07', 3),
(8, 38, '2025-01-20 13:23:05', '2025-01-20 13:44:05', 3),
(9, 37, '2025-01-16 07:04:55', '2025-01-16 07:15:55', 1),
(10, 20, '2025-01-05 20:38:23', '2025-01-05 21:10:23', 4),
(11, 38, '2025-01-19 08:15:42', '2025-01-19 08:57:42', 4),
(12, 10, '2024-12-16 20:23:15', '2024-12-16 20:48:15', 4),
(13, 13, '2024-12-28 23:14:20', '2024-12-28 23:17:20', 5),
(14, 39, '2024-11-24 04:14:29', '2024-11-24 04:23:29', 5),
(15, 19, '2024-12-29 01:22:05', '2024-12-29 01:45:05', 3),
(16, 47, '2024-11-30 04:00:00', '2024-11-30 04:19:00', 1),
(17, 38, '2024-12-18 00:11:38', '2024-12-18 00:46:38', 5),
(18, 5, '2024-11-11 16:21:30', '2024-11-11 16:56:30', 1),
(19, 15, '2025-01-05 14:39:19', '2025-01-05 15:14:19', 2),
(20, 17, '2024-12-18 00:27:23', '2024-12-18 00:45:23', 3),
(21, 29, '2024-12-28 02:49:51', '2024-12-28 03:08:51', 5),
(22, 30, '2024-11-15 18:21:28', '2024-11-15 19:01:28', 2),
(23, 41, '2024-12-11 06:30:36', '2024-12-11 07:03:36', 1),
(24, 32, '2025-01-12 22:12:51', '2025-01-12 22:16:51', 4),
(25, 32, '2024-12-25 23:09:37', '2024-12-25 23:35:37', 3),
(26, 10, '2025-01-13 05:45:54', '2025-01-13 05:53:54', 1),
(27, 20, '2024-12-29 21:14:18', '2024-12-29 21:22:18', 1),
(28, 13, '2025-01-21 14:33:27', '2025-01-21 15:03:27', 1),
(29, 36, '2024-11-02 20:37:48', '2024-11-02 21:21:48', 2);

INSERT INTO tariffs (driver_id, tariff) VALUES 
(1, 'Эконом'),
(2, 'Бизнес'),
(3, 'Комфорт'),
(4, 'Комфорт'),
(5, 'Эконом'),
(6, 'Эконом'),
(7, 'Комфорт'),
(8, 'Комфорт'),
(9, 'Комфорт'),
(10, 'Бизнес'),
(11, 'Эконом'),
(12, 'Бизнес'),
(13, 'Комфорт'),
(14, 'Бизнес'),
(15, 'Комфорт'),
(16, 'Комфорт'),
(17, 'Бизнес'),
(18, 'Бизнес'),
(19, 'Эконом'),
(20, 'Бизнес'),
(21, 'Бизнес'),
(22, 'Комфорт'),
(23, 'Комфорт'),
(24, 'Эконом'),
(25, 'Эконом'),
(26, 'Эконом'),
(27, 'Комфорт'),
(28, 'Комфорт'),
(29, 'Комфорт'),
(30, 'Эконом'),
(31, 'Эконом'),
(32, 'Комфорт'),
(33, 'Комфорт'),
(34, 'Эконом'),
(35, 'Бизнес'),
(36, 'Эконом'),
(37, 'Эконом'),
(38, 'Эконом'),
(39, 'Комфорт'),
(40, 'Эконом'),
(41, 'Эконом'),
(42, 'Эконом'),
(43, 'Эконом'),
(44, 'Комфорт'),
(45, 'Бизнес'),
(46, 'Комфорт'),
(47, 'Бизнес'),
(48, 'Бизнес'),
(49, 'Бизнес');

**РЕШЕНИЕ**

SELECT driver_id
FROM (
    WITH december_stats AS (
        SELECT 
            r.driver_id,
            AVG(r.rating) AS avg_rating,
            COUNT(*) AS total_rides,
            t.tariff
        FROM rides r
        JOIN tariffs t ON r.driver_id = t.driver_id
        WHERE EXTRACT(MONTH FROM r.start_ride) = 12
        GROUP BY r.driver_id, t.tariff
    ),
    max_stats AS (
        SELECT 
            MAX(avg_rating) AS max_rating,
            MIN(avg_rating) AS min_rating,
            MAX(total_rides) AS max_rides,
            MIN(total_rides) AS min_rides
        FROM december_stats
    ),
    scored_drivers AS (
        SELECT 
            ds.driver_id,
            ((ds.avg_rating - ms.min_rating) / NULLIF(ms.max_rating - ms.min_rating, 0) * 0.6 +
             (ds.total_rides - ms.min_rides) / NULLIF(ms.max_rides - ms.min_rides, 0) * 0.4) *
            CASE ds.tariff
                WHEN 'Комфорт' THEN 1.10
                WHEN 'Бизнес' THEN 1.20
                ELSE 1.00
            END AS final_score
        FROM december_stats ds
        CROSS JOIN max_stats ms
    ),
    ranked_drivers AS (
        SELECT 
            driver_id,
            DENSE_RANK() OVER (ORDER BY final_score DESC) as position
        FROM scored_drivers
    )
    SELECT driver_id
    FROM ranked_drivers
    WHERE position <= 10
) AS top_drivers
ORDER BY driver_id;

Ожидаемый результат:
driver_id
---------
5
7
10
13
17
19
20
29
32
38